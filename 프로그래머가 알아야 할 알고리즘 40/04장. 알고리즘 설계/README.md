# 04장. 알고리즘 설계

# 1. 알고리즘 설계의 기본 개념 살펴보기

<aside>
💡 어떤 초기 조건이 주어졌을 때, 특정 목표를 달성하기 위해 규정된 순서에 따라 수행될 수 있으며, 인식 가능한 최종 조건 집합을 가진 명료한 요구사항으로 구성된 유한한 집합이다.

</aside>

- 우리가 풀려는 문제를 완벽히 이해
- 무엇을 완료해야 하는지(요구사항) 파악 → 어떻게 완료할 것인지(알고리즘 설계) 고민
- 기능적 요구사항 : 우리가 풀려는 문제가 가진 입력과 출력 인터페이스와 이에 관한 함수
    - 기대하는 결과를 얻기 위해 구현해야 할 데이터 처리, 가공 및 연산 과정 이해
- 비기능적 요구사항 : 알고리즘의 성능과 보안에 관한 기대치 설정

## 1. 관점 1 - 설계한 알고리즘이 우리가 기대하는 결과를 출력하는가?

- 정답 정의하기 : 일련의 입력 데이터와 그에 대응하는 정확한 결과 존재
- 지표 선택하기 : 알고리즘이 출력한 답이 정답으로부터 얼마나 멀리 떨어져 있는지 정량화하는 방법 고민

## 2. 관점 2 - 설계한 알고리즘이 결과를 얻을 수 있는 최적의 방법인가?

> 현재 해결책이 최선입니까? 현재 보유한 해결책보다 더 나은 해결책이 존재하지 않음을 증명할 수 있습니까?
> 
- 다항시간 알고리즘(Polynomial Time Algorithm) : 알고리즘의 시간 복잡도가 O(N^k)이고 k가 상수
- 증명서(Certificate) : 알고리즘을 반복적으로 개선하는 과정에서 생성되는 후보 해결책

### 1. 문제의 복잡도 파악하기

- 유형 1 : 문제를 해결하는 다항시간 알고리즘이 존재한다는 것이 보장된 문제
- 유형 2 : 다항시간 알고리즘으로 풀 수 없다는 것을 증명할 수 있는 문제
- 유형 3 : 문제를 해결하는 다항시간 알고리즘을 찾아낼 수 없으며, 다항시간 알고리즘으로 문제를 해결할 수 없다는 것도 증명할 수 없는 문제

### 2. 문제 분류

- 비결정론적 다항시간 문제(Non-deterministic Polynomial Time, NP) : 후보 해결책이 최적이라는 것을 증명하는 다항시간 알고리즘 존재
- 다항시간 문제(Polynomial Time, P) : NP 문제 조건 + 문제를 풀 수 있는 다항시간 알고리즘이 최소 한 개 이상 존재
- NP-완전 문제(NP-complete) : 해결책을 생성할 수 있는 알려진 다항시간 알고리즘이 존재하지 않음 + 제안된 해결책이 최적이라는 것을 검증할 수 있는 알려진 다항시간 알고리즘 존재
- NP-난해 문제(NP-hard) : NP 집합에 있는 문제만큼 풀기 어렵지만 NP 집합에는 속하지 않는 문제

## 3. 관점 3 - 설계한 알고리즘이 규모가 더 큰 데이터셋을 다룰 수 있는가?

- 공간 복잡도 분석 : 입력 데이터가 증가하면 필요한 자원도 증가
- 시간 복잡도 분석 : 입력 데이터가 증가하면 이를 처리하는 시간도 증가

# 2. 알고리즘 설계 전략 이해하기

## 1. 분할 및 정복 전략(Divide and Conquer) 이해하기

- 큰 문제를 서로 독립적인 여러 개의 하위 문제로 쪼갬
- 각 하위 문제를 푸는 하위 해결책을 도출 → 모두 모아 전체 문제 해결책으로 합침
1. 스플리팅(Splitting) : 입력 데이터를 여러 개의 파티션으로 쪼갬
2. 매핑(Mapping) : 분할된 각 파티션에 독립적으로 적용되는 연산
3. 셔플링(Shuffling) : 비슷한 키끼리 묶는 작업
4. 리듀싱(Reducing) : 그룹에 적용하는 취합 함수

## 2. 동적 계획법(Dynamic Programming) 이해하기

- 무거운 연산 작업을 재활용하는 똑똑한 캐싱 메커니즘
- 입력 데이터를 반복 처리하는 재귀적 구조를 가진 문제를 풀 때 강력한 성능 발휘

## 3. 탐욕 알고리즘 이해하기

- 알고리즘 오버헤드(Algorithmic Overhead) : 어떤 문제에 최적의 해결책을 찾기 위해서는 시간이 소요
- 최적해와의 차이(Delta from Optimal) : 최적해
- 전략 1 : 시간을 들여 최적해에 가까운 해를 찾으려 노력
- 전략 2 : 알고리즘 오버헤드를 최소화
- 전역적 최적해를 찾으려 노력하는 대신 알고리즘 오버헤드를 최소화하는 방식 선택