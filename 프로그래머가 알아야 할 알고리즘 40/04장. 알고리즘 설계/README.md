# 04장. 알고리즘 설계

# 1. 알고리즘 설계의 기본 개념 살펴보기

<aside>
💡 어떤 초기 조건이 주어졌을 때, 특정 목표를 달성하기 위해 규정된 순서에 따라 수행될 수 있으며, 인식 가능한 최종 조건 집합을 가진 명료한 요구사항으로 구성된 유한한 집합이다.

</aside>

- 우리가 풀려는 문제를 완벽히 이해
- 무엇을 완료해야 하는지(요구사항) 파악 → 어떻게 완료할 것인지(알고리즘 설계) 고민
- 기능적 요구사항 : 우리가 풀려는 문제가 가진 입력과 출력 인터페이스와 이에 관한 함수
    - 기대하는 결과를 얻기 위해 구현해야 할 데이터 처리, 가공 및 연산 과정 이해
- 비기능적 요구사항 : 알고리즘의 성능과 보안에 관한 기대치 설정

## 1. 관점 1 - 설계한 알고리즘이 우리가 기대하는 결과를 출력하는가?

- 정답 정의하기 : 일련의 입력 데이터와 그에 대응하는 정확한 결과 존재
- 지표 선택하기 : 알고리즘이 출력한 답이 정답으로부터 얼마나 멀리 떨어져 있는지 정량화하는 방법 고민

## 2. 관점 2 - 설계한 알고리즘이 결과를 얻을 수 있는 최적의 방법인가?

> 현재 해결책이 최선입니까? 현재 보유한 해결책보다 더 나은 해결책이 존재하지 않음을 증명할 수 있습니까?
> 
- 다항시간 알고리즘(Polynomial Time Algorithm) : 알고리즘의 시간 복잡도가 O(N^k)이고 k가 상수
- 증명서(Certificate) : 알고리즘을 반복적으로 개선하는 과정에서 생성되는 후보 해결책

### 1. 문제의 복잡도 파악하기

- 유형 1 : 문제를 해결하는 다항시간 알고리즘이 존재한다는 것이 보장된 문제
- 유형 2 : 다항시간 알고리즘으로 풀 수 없다는 것을 증명할 수 있는 문제
- 유형 3 : 문제를 해결하는 다항시간 알고리즘을 찾아낼 수 없으며, 다항시간 알고리즘으로 문제를 해결할 수 없다는 것도 증명할 수 없는 문제

### 2. 문제 분류

- 비결정론적 다항시간 문제(Non-deterministic Polynomial Time, NP) : 후보 해결책이 최적이라는 것을 증명하는 다항시간 알고리즘 존재
- 다항시간 문제(Polynomial Time, P) : NP 문제 조건 + 문제를 풀 수 있는 다항시간 알고리즘이 최소 한 개 이상 존재
- NP-완전 문제(NP-complete) : 해결책을 생성할 수 있는 알려진 다항시간 알고리즘이 존재하지 않음 + 제안된 해결책이 최적이라는 것을 검증할 수 있는 알려진 다항시간 알고리즘 존재
- NP-난해 문제(NP-hard) : NP 집합에 있는 문제만큼 풀기 어렵지만 NP 집합에는 속하지 않는 문제

## 3. 관점 3 - 설계한 알고리즘이 규모가 더 큰 데이터셋을 다룰 수 있는가?

- 공간 복잡도 분석 : 입력 데이터가 증가하면 필요한 자원도 증가
- 시간 복잡도 분석 : 입력 데이터가 증가하면 이를 처리하는 시간도 증가

# 2. 알고리즘 설계 전략 이해하기

## 1. 분할 및 정복 전략(Divide and Conquer) 이해하기

- 큰 문제를 서로 독립적인 여러 개의 하위 문제로 쪼갬
- 각 하위 문제를 푸는 하위 해결책을 도출 → 모두 모아 전체 문제 해결책으로 합침
1. 스플리팅(Splitting) : 입력 데이터를 여러 개의 파티션으로 쪼갬
2. 매핑(Mapping) : 분할된 각 파티션에 독립적으로 적용되는 연산
3. 셔플링(Shuffling) : 비슷한 키끼리 묶는 작업
4. 리듀싱(Reducing) : 그룹에 적용하는 취합 함수

## 2. 동적 계획법(Dynamic Programming) 이해하기

- 무거운 연산 작업을 재활용하는 똑똑한 캐싱 메커니즘
- 입력 데이터를 반복 처리하는 재귀적 구조를 가진 문제를 풀 때 강력한 성능 발휘

## 3. 탐욕 알고리즘 이해하기

- 알고리즘 오버헤드(Algorithmic Overhead) : 어떤 문제에 최적의 해결책을 찾기 위해서는 시간이 소요
- 최적해와의 차이(Delta from Optimal) : 최적해
- 전략 1 : 시간을 들여 최적해에 가까운 해를 찾으려 노력
- 전략 2 : 알고리즘 오버헤드를 최소화
- 전역적 최적해를 찾으려 노력하는 대신 알고리즘 오버헤드를 최소화하는 방식 선택

# 3. 페이지랭크(PageRank) 알고리즘 이해하기

- 사용자가 입력한 검색어의 맥락을 바탕으로 검색 결과의 중요도 수치화

## 1. 페이지랭크 알고리즘 구현하기

- 사용자가 입력한 검색어와 관련한 정보
- 사용자가 입력한 검색어와는 상관없는 정보
    
    ```python
    import numpy as np
    import networkx as nx
    import matplotlib.pyplot as plt
    %matplotlib inline
    
    myWeb = nx.DiGraph()
    myPages = range(1, 5)
    
    connections = [(1, 3), (2, 1), (2, 3), (3, 1), (3, 2), (3, 4), (4, 5), (5, 1), (5, 4)]
    myWeb.add_nodes_from(myPages)
    myWeb.add_edges_from(connections)
    
    pos = nx.shell_layout(myWeb)
    nx.draw(myWeb, pos, arrows=True, with_labels=True)
    plt.show()
    
    def createPageRank(aGraph):
        nodes_set = len(aGraph)
        M = nx.to_numpy_matrix(aGraph)
        outwards = np.squeeze(np.asarray(np.sum(M, axis=1)))
        prob_outwards = np.array([1.0 / count if count > 0 else 0.0 for count in outwards])
        G = np.asarray(np.multiply(M.T, prob_outwards))
        p = np.ones(nodes_set) / float(nodes_set)
        if np.min(np.sum(G, axis=0)) < 1.0:
            print('경고: 전이 확률 합의 최솟값이 1보다 작습니다.')
        return G, p
    
    G, p = createPageRank(myWeb)
    print(G)
    ```
    

# 4. 선형 계획법(Linear Programming) 이해하기

- 어떠한 제약 조건이 주어졌을 때 변수를 최소화하거나 최대화하는 현실 세계의 문제를 푸는 데 사용

## 1. 선형 계획법 문제 정의하기

- 문제를 방정식의 집합으로 표현 가능
- 방정식에 사용되는 변수 사이에 일차 방정식 성립
- 목적 함수 정의하기 : 다른 변수들의 선형 함수로 표현
- 제약 조건 설정하기 : 현실 세계의 문제에서 무언가를 최소화하거나 최대화할 때 제약 조건 설정