# 01장. 알고리즘 기초

# 1. 알고리즘 정의하기

> 알고리즘은 어떤 초기 조건의 집합이 주어졌을 때, 인식 가능한 일련의 종료 조건을 가진 특정 목표를 달성하기 위해서 정해진 순서에 따라 수행될 수 있는 명료한 요구사항으로 구성된 유한한 집합
> 

## 1. 알고리즘의 단계

1. 개발 단계
    - 문제 정의
    - 설계 단계 : 알고리즘의 구조, 작동 방식, 구현에 관한 세부 사항 결정, 문서화
    - 구현 단계 : 설계한 알고리즘을 컴퓨터 프로그램으로 변환
2. 배포 단계
3. 사용 단계

# 2. 알고리즘의 로직 표현하기

## 1. 의사코드(Pseudocode) 이해하기

- 알고리즘의 개략적인 특징을 어느 정도 구조화된 방법으로 기술

## 2. 스니펫(Snippet) 사용하기

- 지나치게 상세한 논리 기술을 피하면서도 알고리즘의 중요한 논리와 구조 표현

## 3. 실행 계획 생성하기

- 알고리즘을 여러 작업으로 세분화하여 자세히 설명

# 3. 파이썬 패키지 살펴보기

## 1. 파이썬 패키지

- SciPy 생태계
    - NumPy : 배열, 행렬 데이터 타입 제공
    - Scikit-Learn : 분류, 회귀, 클러스터링, 모델 검증 등 핵심 머신러닝 알고리즘 제공
    - Pandas : 테이블형 자료 구조 제공
    - Matplotlib : 시각화 자료 생성(선차트, 산포도, 막대 차트, 히스토그램, 파이 차트 등)
    - Seaborn : 통계 시각화에 특화된 고급 기능 제공
    - iPython : 파이썬 코드 작성, 테스트, 디버깅

# 4. 알고리즘 설계 기법 이해하기

<aside>
💡 알고리즘이 우리가 기대한 결과를 출력하는가?
이 결과를 얻기 위해 선택한 방법이 최적인가?
이 알고리즘이 규모가 더 큰 데이터셋에도 동작하는가?

</aside>

- 데이터 집약적 알고리즘 : 대규모 데이터를 처리하기 위해 설계된 알고리즘
- 연산 집약적 알고리즘 : 상당히 높은 프로세싱 요구사항이 있지만 대규모 데이터에 사용 X
- 데이터/연산 집약적 알고리즘 : 대규모 데이터에 상당히 큰 연산 수행

## 1. 데이터 차원

- 크기(Volume) : 알고리즘이 처리할 것으로 예상되는 데이터의 크기
- 속도(Velocity) : 새로운 데이터가 생성되는 속도
- 다양성(Variety) : 알고리즘이 처리할 것으로 예상되는 데이터 유형의 수

## 2. 연산 차원

- 스플릿(Split) : 파티션 분리
- 데이터의 특성과 사용하는 알고리즘의 유형 및 가용 리소스 규모에 따라 결정

# 5. 성능 분석하기

## 1. 공간 복잡도 분석(Space Complexity Analysis)

- 알고리즘이 입력 데이터를 처리하는 데 필요한 메모리 양 추정
- 임시 데이터의 개수, 유형 크기 결정
- 탄력적 분산 데이터셋(Resilient Distributed Dataset, RDD)

## 2. 시간 복잡도 분석(Time Complexity Analysis)

- 알고리즘의 구조에 따라 할당된 작업을 완료하는 데 걸리는 시간 추정
- 알고리즘 자체 구조에만 영향

<aside>
💡 특정 문제를 여러 알고리즘으로 풀 수 있을 때 어떤 알고리즘이 시간 효율성 측면에서 가장 좋은가?

</aside>

- 구현 후 프로파일링 분석 방식 : 다양한 후보 알고리즘을 구현하고 실행하여 성능 비교
- 구현 전 이론적 분석 방식 : 알고리즘을 실행하지 않고 성능을 수학적으로 근사하여 비교

## 3. 성능 추적

- 최상의 경우 : 알고리즘이 최고의 성능을 낼 수 있도록 입력 데이터가 정리된 경우
- 최악의 경우 : 작업을 완료하는 데 걸리는 시간이 최대가 되는 경우
- 평균의 경우 : 다양한 입력 데이터를 대표 데이터로 성능 분석 후 평균 계산

## 4. 알고리즘 선택

- 시간 복잡도
- 빅오 표기법

## 5. 빅오 표기법

- 상수 시간 복잡도 `O(1)` : 상수 시간 소요
    - `push` 로 스택에 새 요소를 추가하거나 `pop` 으로 스택에서 요소를 제거하는 작업
    - 해시 테이블에 담긴 요소에 접근하는 방법
- 선형 시간 복잡도 `O(n)` : 입력 크기에 비례
    - 일차원 배열에서 요소를 검색하는 작업
    - 일차원 배열에서 가장 작은 값을 가진 요소를 찾아내는 작업
- 이차 시간 복잡도 `O(n^2)` : 제곱에 비례하여 실행 시간 증가
    - 버블 정렬 알고리즘
    - 중첩 루프문
- 로그 시간 복잡도 `O(log n)` : 로그를 취한 값에 비례
    - 이진 검색

- 근사 알고리즘(Approximate Algorithm) : 정확도를 희생하는 것

# 6. 알고리즘 검증하기

## 1. 결정론적, 비결정론적 알고리즘과 최적, 근사 알고리즘

- 결정론적 알고리즘 : 같은 입력 데이터에 대해 언제나 동일한 결과 출력
- 비결정론적 알고리즘 : 일련의 난수를 추가로 사용 → 입력 데이터가 동일하더라도 매번 다른 결과 출력
- 최적(Exact) 알고리즘 : 문제에 대한 정확한 해결책을 찾아내는 알고리즘, 가정/근사 사용 X
- 근사(Approximate) 알고리즘 : 몇 가지 가정을 사용하여 문제 단순화

## 2. 해석 가능성(Explainability)

- 특정한 결론을 내리는 데 어떤 변수들이 직접 또는 간접 사용됐는지 판단하는 능력